import os
path = os.path.dirname(os.path.abspath(__file__))+'/data/mesh/'

def createAndAddToNode(rootNode, name="theFinger"):
    finger = rootNode.createChild(name)
    finger.createObject('EulerImplicit', name='odesolver', firstOrder='1')
    finger.createObject('SparseLDLSolver', name='preconditioner')

    finger.createObject('MeshVTKLoader', name='loader', filename=path+'finger.vtk')
    finger.createObject('TetrahedronSetTopologyContainer', src='@loader', name='container')
    finger.createObject('MechanicalObject', name='tetras', template='Vec3d')

    ## To be properly simulated and to interact with gravity or inertia forces, an object
    ## also needs a mass. You can add a given mass with a uniform distribution for an object
    ## by adding a UniformMass component to the finger node
    finger.createObject('UniformMass', totalmass=' 0.5')

    ## The next component to add is a FEM forcefield which defines how the object reacts
    ## to a loading (i.e. which deformations are created from forces applied onto it).
    ## Here, because the finger is made of silicone, its mechanical behavior is assumed elastic.
    ## This behavior is available via the TetrahedronFEMForceField component.
    finger.createObject('TetrahedronFEMForceField', template='Vec3d',
                        name='FEM', method='large', poissonRatio='0.3',  youngModulus='18000')

    ## Set the ROI of points of the model to fix.
    ## You can either use "BoxROI"...
    finger.createObject('BoxROI', name='ROI1', box='-15 0 0 5 10 15', drawBoxes='true')
    finger.createObject('RestShapeSpringsForceField', points='@ROI1.indices', stiffness='1e12')

    finger.createObject('LinearSolverConstraintCorrection')

    #################################################################################
    ## Visualization
    fingerVisu = finger.createChild('visual')

    ## Add to this empty node a rendering model made of triangles and loaded from an stl file.
    fingerVisu.createObject('OglModel', filename=path+"finger.stl",
                            template='ExtVec3f', color="0.0 0.7 0.7")

    ## Add a BarycentricMapping to deform the rendering model to follow the ones of the
    ## mechanical model.
    fingerVisu.createObject('BarycentricMapping')
   
    #################################################################################
    ## Cable
    cable = finger.createChild('cable')
    cable.createObject('MechanicalObject',
    position=(
        " -17.5 12.5 2.5 " +
        " -32.5 12.5 2.5 " +
        " -47.5 12.5 2.5 " +
        " -62.5 12.5 2.5 " +
        " -77.5 12.5 2.5 " +
        " -83.5 12.5 4.5 " +
        " -85.5 12.5 6.5 " +
        " -85.5 12.5 8.5 " +
        " -83.5 12.5 10.5 " +
        " -77.5 12.5 12.5 " +
        " -62.5 12.5 12.5 " +
        " -47.5 12.5 12.5 " +
        " -32.5 12.5 12.5 " +
        " -17.5 12.5 12.5 " ))

    # Create a CableConstraint object with a name.
    # the indices are referring to the MechanicalObject's positions.
    # The last indice is where the pullPoint is connected.
    cable.createObject('CableConstraint', name="aCable",
                        indices='0 1 2 3 4 5 6 7 8 9 10 11 12 13',
                        pullPoint="0.0 12.5 2.5")

    # This create a BarycentricMapping. A BarycentricMapping is a key element as it will
    # create a bi-directional link between the cable's DoFs and the finger's ones so that movements
    # of the cable's DoFs will be mapped
    # to the finger and vice-versa;
    cable.createObject('BarycentricMapping')


    # This create a PythonScriptController that permits to programatically implement new behavior
    # or interactions using the Python programming langage. The controller is referring to a
    # file named "controller.py".
    cable.createObject('PythonScriptController', 
                        filename="fingercontroller.py", classname="FingerCableController", autoreload="true")


def createScene(rootNode):
    rootNode.createObject('VisualStyle', displayFlags='showVisualModels showBehaviorModels showCollisionModels showForceFields showInteractionForceFields')
    rootNode.findData('gravity').value='-981.0 0 0';
    rootNode.findData('dt').value="0.01"
    
    rootNode.createObject('RequiredPlugin', name='SofaMiscCollision')
    rootNode.createObject('RequiredPlugin', name='SofaPython')
    rootNode.createObject('RequiredPlugin', name='SoftRobots')
    rootNode.createObject('OglSceneFrame', style="Arrows", alignment="TopRight")
              

    ###################################################################
    # Direct simulation
    ###################################################################
    rootNode.createObject('FreeMotionAnimationLoop')
    rootNode.createObject('GenericConstraintSolver', tolerance="1e-6", maxIterations="1000")
    rootNode.createObject('CollisionPipeline')
    rootNode.createObject('BruteForceDetection')
    rootNode.createObject('RuleBasedContactManager', name="Response",
                            response="FrictionContact", rules="0 * FrictionContact?mu=0.8" )
    rootNode.createObject('LocalMinDistance', name="Proximity",
                            alarmDistance="4", contactDistance="3", angleCone="0.01")

    createAndAddToNode(rootNode)
