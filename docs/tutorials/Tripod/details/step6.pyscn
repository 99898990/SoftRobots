# -*- coding: utf-8 -*-
import Sofa
from stlib.scene import Scene, Interaction
from splib.numerics import RigidDof
from splib.animation import animate
from splib.constants import Key
from math import floor, pi
from tripod import Tripod


def setupanimation(actuators, step, angularstep, factor):
    """This function is called repeatidely in an animation.
       It moves the actuators by translating & rotating them according to the factor
       value.
    """
    for actuator in actuators:
            actuator.servomotor.Position.dofs.rotation = [0., 0., 0.]
            actuator.servomotor.Position.dofs.translation = [0., 0., 0.]
            rigid = RigidDof(actuator.servomotor.Position.dofs)
            rigid.translate(rigid.forward * step * factor)
            actuator.servomotor.angle += angularstep * factor


class MyController(Sofa.PythonScriptController):
    """This controller has two roles:
       - if the user presses up/left/right/down/plus/minus, the servomotor angle
         is changed.
       - if thr user presses A, an animation is started to move the servomotor to the initial position
         of the real robot.
    """

    def __init__(self, node, actuators, serialportctrl):
        self.stepsize = 0.1
        self.actuators = actuators
        self.serialportctrl = serialportctrl

    def onKeyPressed(self, key):
        if key == Key.uparrow:
            self.actuators[0].servomotor.angle += self.stepsize
        elif key == Key.downarrow:
            self.actuators[0].servomotor.angle -= self.stepsize

        if key == Key.leftarrow:
            self.actuators[1].servomotor.angle += self.stepsize
        elif key == Key.rightarrow:
            self.actuators[1].servomotor.angle -= self.stepsize

        if key == Key.plus:
            self.actuators[2].servomotor.angle += self.stepsize
        elif key == Key.minus:
            self.actuators[2].servomotor.angle -= self.stepsize

        if key == Key.A and self.serialportctrl.state == "init":
            self.serialportctrl.state = "no-comm"
            animate(setupanimation, {"actuators": self.actuators, "step": 35.0, "angularstep": -0.14}, duration=0.2)

        for actuator in self.actuators:
            if(actuator.servomotor.angle >- 0.0225):
                actuator.servomotor.angle = -0.0255
            if(actuator.servomotor.angle <- 2.0225):
                actuator.servomotor.angle = -2.0225


# Description of how the communication is handled
def SerialPortBridgeGeneric(rootNode, serialport="/dev/ttyUSB0"):
    return rootNode.createObject("SerialPortBridgeGeneric", port=serialport, baudRate=115200, size=3, listening=True, header=255)


# Data sending controller
class SerialPortController(Sofa.PythonScriptController):
    def __init__(self, node, inputs, serialport):
        self.name = "serialportcontroller"
        self.servos = inputs
        self.serialport = serialport
        self.serialport.packetOut = [150, 150, 150]
        self.state = "init"

    def onEndAnimationStep(self, dt):
        # Data sending if the robot is initializing or in the no-communication sate
        if self.state == "init":
            return

        if self.state == "no-comm":
            return

        # Vector storing the simulated servomotors' angular position
        angles = []

        for servo in self.servos:
            # Conversion of the angle values from radians to degrees
            angleDegree = servo.angle*360/(2.0*pi)
            angleByte = int(floor(angleDegree)) + 179

            # Limitation of the angular position's command
            if angleByte < 60:
                angleByte = 60
            if angleByte > 180:
                angleByte = 180

            # Filling the list of the 3 angle values
            angles.append(angleByte)

        # The controller board of the real robot receives `angles` values
        self.serialport.packetOut = angles


def createScene(rootNode):
    scene = Scene(rootNode, gravity=[0.0, -981.0, 0.0], plugins=["SoftRobots"])
    rootNode.dt = 0.01
    scene.VisualStyle.displayFlags = "showBehavior"

    scene.createObject("MeshSTLLoader", name="loader", filename="data/mesh/blueprint.stl")
    scene.createObject("OglModel", src="@loader")

    model = scene.createChild("Model")
    tripod = Tripod(model)

    serial = SerialPortBridgeGeneric(rootNode)

    # The real robot receives data from the 3 actuators
    serialportctrl = SerialPortController(rootNode, [tripod.ActuatedArm0.ServoMotor,
                                                     tripod.ActuatedArm1.ServoMotor,
                                                     tripod.ActuatedArm2.ServoMotor], serial)

    # The simulation's control with keystrokes is still available
    MyController(rootNode, tripod.actuatedarms, serialportctrl)

    Interaction(rootNode, [tripod.ActuatedArm0,
                           tripod.ActuatedArm1,
                           tripod.ActuatedArm2])
