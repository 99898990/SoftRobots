# -*- coding: utf-8 -*-
import Sofa
from stlib.scene import Scene, ContactHeader
from splib.numerics import sin,cos, to_radians
from stlib.scene import Scene
from splib.constants import Key
from stlib.physics.deformable import ElasticMaterialObject
from stlib.physics.rigid import Sphere
from actuatedarm import ActuatedArm
from math import floor


def ElasticBody(parent):
    body = parent.createChild("ElasticBody")

    e = ElasticMaterialObject(body, 
                              volumeMeshFileName="data/mesh/tripod.gidmsh",rotation=[90,0,0])
    visual = body.createChild("Visual")
    visual.createObject("MeshSTLLoader", name="loader", filename="data/mesh/tripod.stl")
    visual.createObject("OglModel", name="renderer", src="@loader", color=[1.0,1.0,1.0,0.5])

    visual.createObject("BarycentricMapping",
                             input=e.dofs.getLinkPath(),
                             output=visual.renderer.getLinkPath())

    e.addCollisionModel(collisionMesh="data/mesh/tripod.stl")

    return body

def Tripod(parent, name="Tripod", radius=4.0, numMotors=3, angleShift=180.0):
    tripod = parent.createChild(name)
    body = ElasticBody(tripod)
    
    dist = radius
    numstep = numMotors
    for i in range(0,numstep):
        name = "ActuatedArm"+str(i)
        fi = float(i)
        fnumstep = float(numstep)
        angle = fi*360/fnumstep
        angle2 = fi*360/fnumstep+angleShift
        eulerRotation = [0,angle,0]
        translation = [dist*sin(to_radians(angle2)), -1.35, dist*cos(to_radians(angle2))]

        c = ActuatedArm(tripod, name=name,
                                       translation=translation, eulerRotation=eulerRotation,
                                       attachingTo=body.ElasticMaterialObject)
    return tripod

class MyController(Sofa.PythonScriptController):
    def __init__(self, node, actuators):
        self.stepsize = 0.1
        self.actuators = actuators

    def onKeyPressed(self, key):
        if key == Key.uparrow:
            self.actuators[0].ServoMotor.angle += self.stepsize 
        elif key == Key.downarrow:            
            self.actuators[0].ServoMotor.angle -= self.stepsize

        if key == Key.leftarrow:
            self.actuators[1].ServoMotor.angle += self.stepsize 
        elif key == Key.rightarrow:            
            self.actuators[1].ServoMotor.angle -= self.stepsize

        if key == Key.plus:
            self.actuators[2].ServoMotor.angle += self.stepsize 
        elif key == Key.minus:            
            self.actuators[2].ServoMotor.angle -= self.stepsize

        if key == Key.space:
            animate(setupanimation,{"actuators" : self.actuators, "step" : 0.13, 
                                    "angularstep" : -0.12}, duration=0.2)  

def SerialPortBridgeGeneric(rootNode, serialport="/dev/ttyUSB0"):
    return rootNode.createObject("SerialPortBridgeGeneric", port=serialport, baudRate=115200, size=3, listening=True)
    
class SerialPortController(Sofa.PythonScriptController):
    def __init__(self, node, inputs, serialport):
        self.name = "serialportcontroller"
        self.servos = inputs
        self.serialport = serialport
        self.serialport.sentData = [0.1,0.1,0.1]

    def onEndAnimationStep(self, dt):
        angles = []
        
        for servo in self.servos:
            angles.append( to_radians(servo.angle) )

        print("Send the angles "+str(angles)) 
        self.serialport.sentData = angles 

def createScene(rootNode):
    scene = Scene(rootNode, plugins=["SoftRobots"])
    scene.VisualStyle.displayFlags="showBehavior"

    ContactHeader(rootNode, alarmDistance=0.1, contactDistance=0.01)
    
    model = scene.createChild("Model")
    Sphere(model, translation=[0.0,2.0,0.0])

    tripod = Tripod(model)

    serial = SerialPortBridgeGeneric(rootNode)
    SerialPortController(rootNode, [tripod.ActuatedArm0.ServoMotor, 
                                    tripod.ActuatedArm1.ServoMotor,
                                    tripod.ActuatedArm2.ServoMotor], serial)

    MyController(rootNode, [tripod.ActuatedArm0, 
                            tripod.ActuatedArm1, 
                            tripod.ActuatedArm2])

    simu = scene.createChild("SimulationPlan")
    simu.createObject("EulerImplicit")    
    simu.createObject("CGLinearSolver")
    simu.addChild(tripod.ActuatedArm0)
    simu.addChild(tripod.ActuatedArm1)
    simu.addChild(tripod.ActuatedArm2)

