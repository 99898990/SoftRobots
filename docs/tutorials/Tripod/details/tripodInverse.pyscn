""" Sofa simulation for the control of the "tripod' robot: finds the inverse of the model

	This simulation is part of the SoftRobot toolkit available at:
		https://github.com/SofaDefrost/SoftRobots

	Example of use:
		def createScene(rootNode):
			from stlib.scene import MainHeader
			from tripod import Tripod
			from tripodInverse import addSimulationPlan
			scene = MainHeader(rootNode, plugins=["SoftRobots"])
			scene.getObject("VisualStyle").displayFlags="showForceFields"

			model = Node(rootNode, "Model")
			tripod = Tripod(model)

			simulation = Node(rootNode, "SimulationPlan")
			addSimulationPlan(simulation, tripod)

			return rootNode
"""
from stlib.scene import Node
from stlib.algorithms import get
from stlib.numerics import *

from softrobots.inverse.effectors import PositionEffector, EffectorGoal

from math import sin,cos

from tripod import ActuatedArmWithConstraint, Tripod, ElasticBody


# The components StiffSpringForceField needs a list of springs of the form:
#                [node_i_model1, node_i_model2, stiffness, damping, restLength]
# This list allows to set up each spring between model1 and model2
# The function GenerateSprings generate this list from the following arguments:
#   indices1 : list of indices of model1
#   indices2 : list of indices of model2 (size should be the same of indices1)
#   stiffness : scalar, stiffness of all the springs
#   damping : scalar, damping of all the springs
#   restLength : scalar, length at rest of all the springs
def GenerateSprings(indices1, indices2, stiffness=1e12, damping=5, restLength=0.001):

	spring = []
	size1 = len(indices1)
	size2 = len(indices2)

	if size1 != size2:
		return spring

	spring = [[0.,0.,0.,0.,0.]]*size1
	for i in range(0,size1):
		spring[i] = [indices1[i],indices2[i],stiffness,damping,restLength]

	return spring


def addSimulationPlan(parentNode, modelNode):

	parentNode.createObject("DefaultAnimationLoop")
	parentNode.createObject("DefaultVisualManagerLoop")
	parentNode.createObject("QPInverseProblemSolver")

	goal = EffectorGoal(parentNode, position=[[0,4,0]], visuScale=0.2)

	part1 = Node(parentNode, "MechanicalPart1")
	part1.createObject("EulerImplicit")
	part1.createObject("SparseLDLSolver")
	part1.addChild( get(modelNode, "ElasticBody") )

	PositionEffector(get(modelNode, "ElasticBody/ElasticMaterialObject"), position=[[0,0,0]], effectorGoal=get(goal, 'MechanicalObject.position').getLinkPath())

	part2 = Node(parentNode, "MechanicalPart2")
	part2.createObject("EulerImplicit")
	part2.createObject("CGLinearSolver")

	## Add constraint

	## Initialisation needed for the generation of springs
	elasticBody = get(modelNode, "ElasticBody/ElasticMaterialObject")
	get(elasticBody, 'MeshLoader').init()
	get(elasticBody, 'container').init()
	get(elasticBody, 'MechanicalObject').init()

	for i in range(0,3):
		actuatedArm = get(modelNode, "ActuatedArm"+str(i))
		part2.addChild(actuatedArm)

		wheel = get(actuatedArm, 'ServoMotor/ServoWheel')
		wheel.createObject('SlidingActuator', template="Rigid", indices="0", direction="0 0 0 1 0 0")

		## Initialisation needed for the generation of springs
		boxROI = get(actuatedArm, 'Constraint/BoxROI')
		boxROI.init()
		spring = GenerateSprings(range(0,boxROI.nbIndices), get(actuatedArm, 'Constraint/BoxROI.indices').value)

		elasticBody.createObject('StiffSpringForceField',
								name='StiffSpringForceField'+str(i),
								spring=spring,
								object1=get(actuatedArm, 'Constraint/MechanicalObject').getLinkPath(),
								object2="@./")

		elasticBody.createObject('MappedMatrixForceFieldAndMass',
								template="Vec3d,Rigid3d",
								name='MappedMatrixForceFieldAndMass'+str(i),
								object1=get(actuatedArm,'Constraint/MechanicalObject').getLinkPath(),
								object2=get(actuatedArm,'MechanicalObject').getLinkPath(),
								mappedForceField="@./TetrahedronFEMForceField",
								mappedMass="@./UniformMass")

	return parentNode

def createScene(rootNode):
	from stlib.scene import MainHeader
	scene = MainHeader(rootNode, plugins=["SoftRobots"])
	scene.getObject("VisualStyle").displayFlags="showForceFields showInteractionForceFields"

	model = Node(rootNode, "Model")
	tripod = Tripod(model)

	simulation = Node(rootNode, "SimulationPlan")
	addSimulationPlan(simulation, tripod)

	return rootNode
