import os
path = os.path.dirname(os.path.abspath(__file__))+'/data/mesh/'

def createAndAddToNode(rootNode, name="theFinger"):
    finger = rootNode.createChild(name)
    finger.createObject('EulerImplicit', name='odesolver', firstOrder='1')
    finger.createObject('SparseLDLSolver', name='preconditioner')

    finger.createObject('MeshVTKLoader', name='loader', filename=path+'finger.vtk')
    finger.createObject('TetrahedronSetTopologyContainer', src='@loader', name='container')
    finger.createObject('MechanicalObject', name='tetras', template='Vec3d')

    ## To be properly simulated and to interact with gravity or inertia forces, an object
    ## also needs a mass. You can add a given mass with a uniform distribution for an object
    ## by adding a UniformMass component to the finger node
    finger.createObject('UniformMass', totalmass=' 0.5')

    ## The next component to add is a FEM forcefield which defines how the object reacts
    ## to a loading (i.e. which deformations are created from forces applied onto it).
    ## Here, because the finger is made of silicone, its mechanical behavior is assumed elastic.
    ## This behavior is available via the TetrahedronFEMForceField component.
    finger.createObject('TetrahedronFEMForceField', template='Vec3d',
                        name='FEM', method='large', poissonRatio='0.3',  youngModulus='18000')

    ## Set the ROI of points of the model to fix.
    ## You can either use "BoxROI"...
    finger.createObject('BoxROI', name='ROI1', box='-15 0 0 5 10 15', drawBoxes='true')
    finger.createObject('RestShapeSpringsForceField', points='@ROI1.indices', stiffness='1e12')

    finger.createObject('LinearSolverConstraintCorrection')

    #################################################################################
    ## Visualization
    fingerVisu = finger.createChild('visual')

    ## Add to this empty node a rendering model made of triangles and loaded from an stl file.
    fingerVisu.createObject('OglModel', filename=path+"finger.stl",
                            template='ExtVec3f', color="0.0 0.7 0.7")

    ## Add a BarycentricMapping to deform the rendering model to follow the ones of the
    ## mechanical model.
    fingerVisu.createObject('BarycentricMapping')

    return finger

def createScene(rootNode):
    rootNode.findData('gravity').value='-981.0 0 0';
    rootNode.findData('dt').value="0.01"

    rootNode.createObject('RequiredPlugin', name='SofaMiscCollision')
    rootNode.createObject('RequiredPlugin', name='SofaPython')
    rootNode.createObject('RequiredPlugin', name='SoftRobots')
    rootNode.createObject('OglSceneFrame', style="Arrows", alignment="TopRight")

    ###################################################################
    # Direct simulation
    ###################################################################
    rootNode.createObject('FreeMotionAnimationLoop')
    rootNode.createObject('GenericConstraintSolver', tolerance="1e-6", maxIterations="1000")
    rootNode.createObject('CollisionPipeline')
    rootNode.createObject('BruteForceDetection')
    rootNode.createObject('RuleBasedContactManager', name="Response",
                            response="FrictionContact", rules="0 * FrictionContact?mu=0.8" )
    rootNode.createObject('LocalMinDistance', name="Proximity",
                            alarmDistance="4", contactDistance="3", angleCone="0.01")

    createAndAddToNode(rootNode)
